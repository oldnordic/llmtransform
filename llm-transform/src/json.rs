use serde::{Deserialize, Serialize};
use std::time::{SystemTime, UNIX_EPOCH};
use uuid::Uuid;

/// Request to apply edits to a file
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EditRequest {
    /// Unique identifier for this execution (generated by client, or use "auto" for server generation)
    #[serde(default = "default_execution_id")]
    pub execution_id: String,
    /// Path to the file to edit
    pub file_path: String,
    /// Expected BLAKE3 checksum of the file before editing
    pub expected_checksum: String,
    /// Edits to apply (will be sorted by byte_start descending)
    #[serde(default)]
    pub edits: Vec<EditJson>,
}

fn default_execution_id() -> String {
    "auto".to_string()
}

/// Helper to generate a new execution_id
pub fn generate_execution_id() -> String {
    Uuid::new_v4().to_string()
}

/// Single edit in JSON format
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EditJson {
    /// Byte offset where the edit starts (inclusive)
    pub byte_start: usize,
    /// Byte offset where the edit ends (exclusive)
    pub byte_end: usize,
    /// Replacement text
    pub replacement: String,
}

/// Response after applying edits
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EditResponse {
    /// Unique identifier for this execution (echoed from request or generated)
    pub execution_id: String,
    /// Whether all edits were applied successfully
    pub success: bool,
    /// Final checksum after all edits
    pub final_checksum: String,
    /// Total byte shift across all edits
    pub total_byte_shift: i64,
    /// Number of edits applied
    pub applied_count: usize,
    /// Number of edits skipped
    pub skipped_count: usize,
    /// Number of edits that failed
    pub error_count: usize,
    /// Individual edit results
    pub edits: Vec<PerEditResultJson>,
    /// Error message if operation failed
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
}

/// Result of a single edit in JSON format
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PerEditResultJson {
    /// Original byte offset of this edit
    pub byte_offset: usize,
    /// Result type: "applied", "skipped", or "error"
    pub status: String,
    /// New checksum after this edit (only if applied)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub new_checksum: Option<String>,
    /// Byte shift introduced by this edit (only if applied)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub byte_shift: Option<i64>,
    /// Reason or error message (for skipped/error)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reason: Option<String>,
}

impl EditResponse {
    /// Create a success response
    pub fn success(
        execution_id: String,
        final_checksum: String,
        total_byte_shift: i64,
        applied_count: usize,
        skipped_count: usize,
        edits: Vec<PerEditResultJson>,
    ) -> Self {
        Self {
            execution_id,
            success: true,
            final_checksum,
            total_byte_shift,
            applied_count,
            skipped_count,
            error_count: 0,
            edits,
            error: None,
        }
    }

    /// Create a failure response
    pub fn failure(execution_id: String, error: String) -> Self {
        Self {
            execution_id,
            success: false,
            final_checksum: String::new(),
            total_byte_shift: 0,
            applied_count: 0,
            skipped_count: 0,
            error_count: 0,
            edits: Vec::new(),
            error: Some(error),
        }
    }
}

/// Single log entry for an execution event
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutionLogEntry {
    /// Timestamp in milliseconds since Unix epoch
    pub timestamp_ms: u64,
    /// Event type: "started", "edit_applied", "edit_skipped", "edit_error", "completed", "failed"
    pub event: String,
    /// Byte offset (for edit-related events)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub byte_offset: Option<usize>,
    /// Message or details
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}

impl ExecutionLogEntry {
    /// Create a new log entry with current timestamp
    pub fn new(event: impl Into<String>) -> Self {
        Self {
            timestamp_ms: current_timestamp_ms(),
            event: event.into(),
            byte_offset: None,
            message: None,
        }
    }

    /// Add byte offset to the log entry
    pub fn with_byte_offset(mut self, offset: usize) -> Self {
        self.byte_offset = Some(offset);
        self
    }

    /// Add message to the log entry
    pub fn with_message(mut self, msg: impl Into<String>) -> Self {
        self.message = Some(msg.into());
        self
    }
}

/// Execution log containing all events for an operation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutionLog {
    /// Execution ID this log is for
    pub execution_id: String,
    /// Log entries in chronological order
    pub entries: Vec<ExecutionLogEntry>,
}

impl ExecutionLog {
    /// Create a new execution log
    pub fn new(execution_id: String) -> Self {
        Self {
            execution_id,
            entries: Vec::new(),
        }
    }

    /// Add an entry to the log
    pub fn add(&mut self, entry: ExecutionLogEntry) {
        self.entries.push(entry);
    }

    /// Add a "started" event
    pub fn started(&mut self, file_path: &str) {
        self.add(ExecutionLogEntry::new("started")
            .with_message(format!("Processing file: {}", file_path)));
    }

    /// Add an "edit_applied" event
    pub fn edit_applied(&mut self, byte_offset: usize, new_checksum: &str) {
        self.add(ExecutionLogEntry::new("edit_applied")
            .with_byte_offset(byte_offset)
            .with_message(format!("New checksum: {}", new_checksum)));
    }

    /// Add an "edit_skipped" event
    pub fn edit_skipped(&mut self, byte_offset: usize, reason: &str) {
        self.add(ExecutionLogEntry::new("edit_skipped")
            .with_byte_offset(byte_offset)
            .with_message(reason.to_string()));
    }

    /// Add an "edit_error" event
    pub fn edit_error(&mut self, byte_offset: usize, error: &str) {
        self.add(ExecutionLogEntry::new("edit_error")
            .with_byte_offset(byte_offset)
            .with_message(error.to_string()));
    }

    /// Add a "completed" event
    pub fn completed(&mut self, applied_count: usize, final_checksum: &str) {
        self.add(ExecutionLogEntry::new("completed")
            .with_message(format!(
                "Applied {} edits, final checksum: {}",
                applied_count, final_checksum
            )));
    }

    /// Add a "failed" event
    pub fn failed(&mut self, error: &str) {
        self.add(ExecutionLogEntry::new("failed")
            .with_message(error.to_string()));
    }
}

/// Get current timestamp in milliseconds since Unix epoch
fn current_timestamp_ms() -> u64 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_millis() as u64
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_edit_request_serialize() {
        let request = EditRequest {
            execution_id: "test-exec-123".to_string(),
            file_path: "/path/to/file.txt".to_string(),
            expected_checksum: "abc123def456".to_string(),
            edits: vec![
                EditJson {
                    byte_start: 0,
                    byte_end: 5,
                    replacement: "Hello".to_string(),
                },
            ],
        };

        let json = serde_json::to_string(&request);

        assert!(json.is_ok());
        let json_str = json.unwrap();

        // Verify the JSON contains our fields
        assert!(json_str.contains("test-exec-123"));
        assert!(json_str.contains("/path/to/file.txt"));
        assert!(json_str.contains("abc123def456"));
        assert!(json_str.contains("Hello"));
    }

    #[test]
    fn test_edit_request_deserialize() {
        let json_str = r#"{
            "execution_id": "test-exec-456",
            "file_path": "/another/file.txt",
            "expected_checksum": "xyz789",
            "edits": [
                {
                    "byte_start": 10,
                    "byte_end": 20,
                    "replacement": "World"
                }
            ]
        }"#;

        let result: Result<EditRequest, _> = serde_json::from_str(json_str);

        assert!(result.is_ok());
        let request = result.unwrap();

        assert_eq!(request.execution_id, "test-exec-456");
        assert_eq!(request.file_path, "/another/file.txt");
        assert_eq!(request.expected_checksum, "xyz789");
        assert_eq!(request.edits.len(), 1);
        assert_eq!(request.edits[0].byte_start, 10);
        assert_eq!(request.edits[0].byte_end, 20);
        assert_eq!(request.edits[0].replacement, "World");
    }

    #[test]
    fn test_edit_response_serialize() {
        let response = EditResponse::success(
            "exec-789".to_string(),
            "new-checksum-123".to_string(),
            5,
            2,
            0,
            vec![],
        );

        let json = serde_json::to_string(&response);

        assert!(json.is_ok());
        let json_str = json.unwrap();

        // Verify the JSON contains our fields
        assert!(json_str.contains("exec-789"));
        assert!(json_str.contains("new-checksum-123"));
        assert!(json_str.contains("\"success\":true"));
    }

    #[test]
    fn test_generate_execution_id() {
        let id1 = generate_execution_id();
        let id2 = generate_execution_id();

        // IDs should be different (UUID v4 uniqueness)
        assert_ne!(id1, id2);

        // ID should be a valid UUID format (8-4-4-4-12 hex digits)
        assert_eq!(id1.len(), 36); // Standard UUID string length

        // Verify it only contains valid UUID characters (hex digits and hyphens)
        for c in id1.chars() {
            assert!(c.is_ascii_hexdigit() || c == '-');
        }

        // Should contain hyphens in the right places
        let parts: Vec<&str> = id1.split('-').collect();
        assert_eq!(parts.len(), 5);
        assert_eq!(parts[0].len(), 8);
        assert_eq!(parts[1].len(), 4);
        assert_eq!(parts[2].len(), 4);
        assert_eq!(parts[3].len(), 4);
        assert_eq!(parts[4].len(), 12);
    }

    #[test]
    fn test_execution_log_entry() {
        let entry = ExecutionLogEntry::new("test_event")
            .with_byte_offset(100)
            .with_message("Test message");

        // Should have a timestamp
        assert!(entry.timestamp_ms > 0);

        // Should have the event
        assert_eq!(entry.event, "test_event");

        // Should have the byte offset
        assert_eq!(entry.byte_offset, Some(100));

        // Should have the message
        assert_eq!(entry.message, Some("Test message".to_string()));

        // Verify it can be serialized
        let json = serde_json::to_string(&entry);
        assert!(json.is_ok());
    }
}
